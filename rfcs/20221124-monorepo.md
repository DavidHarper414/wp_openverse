‚ÜñÔ∏è Table of Contents

# RFC: Monorepo

**Status:** üöß WIP, comments are welcome nonetheless

## Reviewers

- [ ] @zackkrida
- [ ] @sarayourfriend

## Rationale

For a comprehensive discussion about the pros, the cons and the counterpoints to each see [discussion](https://github.com/WordPress/openverse/issues/192). This is not the purpose of this RFC.

This RFC summarily lists the benefits and then, with the twin assumptions of a monorepo being ultimately beneficial and the decision to migrate being finalised in the above discussion, proceeds to go into the implementation details.

### Benefits of monorepo

1. Single place for everything:

   **Current criticism:** We currently have many repos, and issues and PRs spanning all of them. While this makes it easier for us as maintainers to focus our efforts, it's not easy for contributors. Let's say you were a new contributor looking for good-first Python issues. We shouldn't expect them to search in 3 repos `openverse`, `openverse-api` and `openverse-catalog`. We address this by making tools like Overvue or using search terms like this:

   ```
   is:open is:issue repo:WordPress/openverse-catalog repo:WordPress/openverse repo:WordPress/openverse-api repo:WordPress/openverse-frontend repo:WordPress/openverse-infrastructure sort:updated-desc
   ```

   The search term above perfectly illustrates the problem: we forgot about the extension. It's unwieldy and hard to quickly reach and share.

   **Monorepo solution:** We could use GitHub's own filters to narrow down what we're looking for.

1. Meta-issues:

   **Current criticism:** If an issue spans more than a single layer of the stack, we need to open a meta issue in `WordPress/openverse`, open sub-issues in each of the different repos, then manually close meta issues after the sub-issues are closed. Same goes for PRs. We make individual PRs for every layer and then have to cross-reference them so that reviewers can see the full picture. Meta issues are good when a work needs to split into subtasks, but they are not good for cross-repo work splitting, especially when the work happens completely outside the knowledge of the meta-issue.

   **Monorepo solution:** A monorepo allows our cross-layer PRs to be viewed more holistically and be reviewed as a complete change.

1. No more sync:

   Current criticism: We use complex sync workflows to keep files in sync. Some workflows need to by synced to some repos only. Some workflows shouldn't even be in the repo they're synced from. Some files need subtle differences so we compile Jinja templates for them. We also sync GitHub labels and branch management rules. It's a mess (I would know!).

   **Monorepo solution:** A monorepo would just eliminates all of this and saves the time and effort that goes into maintaining these systems.

1. Unified documentation:

   **Current criticism:** Having many repos, each with its own doc site means two things. Common docs such as contribution process needs to be repeated several times and repo-specific docs get siloed and can only reference each other with external links. Also changing docs in one repo will break any links pointing to it.

   **Monorepo solution:** A better system would be one cohesive doc site, for which the API already has a framework that other repos can just use.

1. Infra included:

   **Current criticism:** Our deployment workflows have code duplication. Secrets are stored in lots of repos, we keep secrets synced using Terraform. Containers are used in the infra repo but published in their individual repos.

   **Monorepo solution:** Monorepo enables the infra to coexist with the code (albeit in a separate module). Apart from the (encrypted) private secrets, the IaC could be open-sourced similar to the rest of the codebase. Our deployment workflows can share code and deployment secrets.

1. GitHub Milestones:

   Milestones are confined by repository boundaries. To have milestones that cover issues in different layers of our stack, the only way is for them to be in a monorepo. This is a limitation imposed by GitHub and there is no workaround for this.

The overarching theme is that there are workarounds for everything. We have been working with split repos quite productively for over a year. My proposition is the the monorepo solutions are better than workarounds.

The [integration](#step-4-integration) section in the latter part of the document describes more interesting outcomes made possible by the monorepo. They may or may not be exclusive to monorepos but they're surely made easier by it.

## Migration path

First we will merge the API and the frontend. This decision was made for the following reasons.

1. API and frontend are tightly linked. The frontend is a direct consumer of what the API produces.

1. The API and frontend form the "service" side of Openverse that directly faces the users (both API consumers and Search engine users).

1. The frontend uses ECS deployments and the API is well on the same track. This makes it possible for them to share some deployment code.

1. To the RFC author, the API and frontend are very familiar so merging them would be easier. Adding a third component would make the task daunting.

1. Merging incurs a productivity hit for the initial transition. So merging everything in one swoop is not ideal.

1. The API‚Äôs comprehensive tooling for developer documentation can benefit frontend devs and create a unified docs site for contributors.

1. The API is already organised by stack folders so the `frontend/` directory will fit right in with the others like `api/` and `ingestion_server/`.

1. The API and frontend share identical tooling for Git hooks, linting and formatting. We will fight our tools less and encounter minimal friction.

   - In fact, we employ a number of hacks to install and configure pre-commit for the frontend. Merging it with the API eliminates the need for such hacks.

1. The entire system can be integration tested during releases. The real API, populated with test data, can even replace the Talkback server.

The `WordPress/openverse-api` repo will absorb the `WordPress/openverse-frontend` repo. The `WordPress/openverse-catalog` will also be merged, _later_.

### Reference

I'm following the steps listed below in a fork at [@dhruvkb/monopenverse](https://github.com/dhruvkb/monopenverse/). You can refer to the fork, but note that it is a comes from a place of haste and has not been treated with the same level of love and care that the final treatment will receive.

### Step 0: Prerequisites

#### Get the timing right

The first step will be to release the frontend, call a code freeze and pause work on it. This is to prevent the frontend repo from continuing to drift as we merge a snapshot of it with the API.

This can prove difficult given how productive our team is, so we will need to channel this productivity towards the catalog in the meantime. I can foresee the end-to-end migration taking one week (ideal scenario) to one fortnight (worst case scenario).

### Step 1: Merge with histories

This is a quick process.

1. Move the entire content of frontend inside a `frontend/` directory, except the following top-level files and folders. Please comment if you can add to this list.

   - `.github/`
   - `.editorconfig`
   - `justfile`
   - `.pre-commit-config.yaml`
   - `prettier.config.js`
   - `.prettierignore`
   - `.eslintrc.js` (need to update references in nested `eslintrc.js` files)
   - `.eslintignore`
   - <s>`.gitignore`</s> (better to move it into the `frontend/` directory and update some absolute paths)

1. Create the final commit on the `WordPress/openverse-frontend` repo. After the merge we might want to add a notice about the migration to the `README.md` file but GitHub's built-in archival process could suffice here.

1. Merge this repo's `main` branch into the `WordPress/openverse-api` repo's `main` branch (see Git docs for `--allow-unrelated-histories`). There will be some conflicts but they will be small and infrequent. [[implementation details](#conflict-resolution)]

1. Create "stack: \*" labels to help with issue and PR management. Spoiler/foreshadowing: these labels will be used for more things later.

1. Migrate issues from `WordPress/openverse-frontend` to `WordPress/openverse-api`. @obulat's has done prior work in this department (when we migrated from CC Search to Openverse) but that might not be as useful because in this case, we can directly transfer the issues, retaining all their comments. Apply the "stack: frontend" label to them. [[implementation details](#issue-transfer)]

With this done, we can archive the frontend repo.

#### Conflict resolution

The following conflicts may occur during merge.

- `.prettierignore`: concatenate
- `.pre-commit-config.yaml`: use from [dhruvkb/monopenverse](https://github.com/dhruvkb/monopenverse)
- Workflows can conflict but they can be renamed and kept alongside each other, _for now_.

#### Issue transfer

As far as I can tell, issue transfer can only be performed via the GitHub GraphQL API ([docs](https://docs.github.com/en/graphql/reference/mutations#transferissue)) and not via the REST API. From my limited testing, transferred issues seem to retain labels (provided they exist in the target repo).

An implementation of the GraphQL API call (albeit in Ruby) is available in `hub` and the [code for it](https://github.com/github/hub/commit/4c2e44146988dfb385a26f649298f274a5017756) is available in their GitHub repo for reference.

However, instead of writing the code ourselves, we can install `hub` and run a small script that repeatedly calls `hub` to migrate each issue one by one. That'll be a hack but it's okay since this is a one-off use for this.

### Step 2. Restore workflows

The workflows of both the API and frontend will need some refactoring to start, and pass, again. [monopenverse](https://github.com/dhruvkb/monopenverse) has updated these workflows and the following work.

[monopenverse](https://github.com/dhruvkb/monopenverse) showcases a `setup-env` action that sets up Node.js, Python, Just and other dependencies and can be used in every workflow.

The `ci_cd.yml` workflow from the API has been very nicely combined with the `ci.yml` workflow from the frontend. Redundant steps were eliminated.

The following actions have been successfully combined:

- actionlint ‚úÖ
- bundle_size.yml ‚úÖ
- ci_cd.yml (API) + ci.yml (frontend) [merged] ‚úÖ
- Playwright tests from ci.yml (frontend) ‚úÖ
- draft_release.yml ‚úÖ
- generate_pot.yml ‚úÖ
- gh_pages.yml ‚úÖ
- migration_safety_warning.yml ‚úÖ
- subscribe_to_label.yml ‚úÖ
- label_new_pr.yml ‚úÖ
- pr_closed.yml ‚úÖ
- pr_label_check.yml ‚úÖ
- new_issues.yml ‚úÖ
- pr_ping.yml ‚úÖ

The following have not been verified to work:

- renovate.yml
- rollback.yml
- ghcr.yml
- push_docker_image.yml

With this done, the development on the frontend can continue inside the subdirectory.

### Step 3. Buff the rough edges

There will be a few rough edges that I cannot foresee and we can continuously fix those as we spot them. But up to this point we should be in a position where
we can continue to build the API and the frontend independently but from one repo.

1. The action `banyan/auto-label` will need to be configured (`auto-label.json`) to add the "stack: \*" labels based on the modified directory.

### Step 4. Integration

This is the long term combination of code for the frontend and the API.

#### Combined lint

All lint steps can be combined in `.pre-commit-config.yaml`. This also simplifies the CI jobs can now be merged.

See the combined lint in action at [monopenverse](https://github.com/dhruvkb/monopenverse).

### Step 5. Documentation merge

The following documentation files will need reorganisation or merge.

- README.md (both repos)
- CODE_OF_CONDUCT.md (both repos)
- CONTRIBUTING.md (both repos)
- CONTRIBUTORS.md (API only; also why?)
- DOCUMENTATION_GUIDELINES.md (API only)
- TESTING_GUIDELINES.md (frontend only)
- DEPLOYMENT.md (frontend only)

I will need more information about this because IANAL.

- LICENSE (both repos)
